#!/bin/bash

# Original: https://github.com/cycneuramus/git-sops
# git-sops: Integrate the sops secrets manager with Git smudge/clean filters
# Enables automatic encryption/decryption of tracked secrets via .gitattributes

set -euo pipefail

self_path=$(readlink -f "$0")
self_dir=$(dirname $self_path)
git_filter_name=sops
encryption_marker="ENC\["

repo_root=$(git rev-parse --show-toplevel)
default_sops_config="$repo_root/.sops.yaml"
sops_config=${SOPS_CONFIG:-$default_sops_config}

tmpdir="$(mktemp -d)"
cleanup() {
  rm -rf $tmpdir
}
trap cleanup EXIT

usage() {
  cat <<-EOF
		Usage: $0 <command> [file]

		Commands:
		  init         Initialize Git repo with smudge/clean filters
		  smudge FILE  Decrypt FILE during checkout
		  clean FILE   Encrypt FILE before staging

		Environment:
		  SOPS_CONFIG  Path to sops.yaml (default: ${default_sops_config})
	EOF
}

# Check if a file exists in HEAD
exists_in_head() {
  local file="$1"
  git cat-file -e "HEAD:$file" &>/dev/null
}

# Check if a file is encrypted by searching for the encryption marker
is_encrypted() {
  local file=$1
  if [[ ! -f "$file" ]]; then
    return
  fi

  grep -q "$encryption_marker" "$file"
}

# Check if the Git repository has already been initialized with the filter
is_initialized() {
  git config --get "filter.${git_filter_name}.required" &>/dev/null &&
    git config --get "filter.${git_filter_name}.smudge" &>/dev/null &&
    git config --get "filter.${git_filter_name}.clean" &>/dev/null
}

# Check if the working copy of a file actually differs from its decrypted content in HEAD
is_changed() {
  local file="$1"
  local file_type

  # If the file does not exist in HEAD, consider it changed (new file)
  if ! exists_in_head "$file"; then
    return 0
  fi

  file_type=$(get_file_type "$file")

  # Compare the decrypted HEAD contents to the working file via streaming
  ! cmp -s "$file" <(git cat-file -p "HEAD:$file" | secrets decrypt /dev/stdin "$file" "$file_type")
}

# Determine the type of file for use with sops
get_file_type() {
  local file="$1"
  case "$file" in
  *.json*) echo "json" ;;
  *.yaml* | *.yml* | *talosconfig* | *kubeconfig*) echo "yaml" ;;
  *.env* | *.dotenv*) echo "dotenv" ;;
  *.ini* | *credentials*) echo "ini" ;;
  *) echo "binary" ;;
  esac
}

# Encrypt/decrypt file with sops
secrets() {
  local action=$1
  local stdin=$2
  local file=$3
  local file_type=$4

  if [[ "$action" != @(encrypt|decrypt) ]]; then
    echo "Error: Invalid action. Use 'encrypt' or 'decrypt'" >&2
    exit 1
  fi

  mise -C $repo_root exec sops -- sops --config "$sops_config" \
    --input-type "$file_type" \
    --output-type "$file_type" \
    --filename-override "$file" \
    --"$action" "$stdin"
}

write_stdin_to_tmpfile() {
  tmpfile=$(mktemp $tmpdir/git-sops.XXXX)
  cat /dev/stdin >$tmpfile
  echo -n $tmpfile
}

# Decrypt the contents of encrypted files in a repository
decrypt_repo() {
  git ls-files | while read -r file; do
    decrypt_file $file
  done
}

decrypt_file() {
  local file=$1

  if is_encrypted "$file"; then
    # Explicitly ignore the clean filter here
    git -c filter.${git_filter_name}.clean=cat rm --cached "$file" &>/dev/null
    git -c filter.${git_filter_name}.clean=cat checkout HEAD -- "$file"
  fi
}

# Initialize repository with the smudge and clean filter
init() {
  if is_initialized; then
    echo "Repository already initialized; skipping"
    return
  fi

  git config --local "filter.${git_filter_name}.required" true
  git config --local "filter.${git_filter_name}.smudge" "$self_path smudge '%f'"
  git config --local "filter.${git_filter_name}.clean" "$self_path clean '%f'"
  echo "Repository initialized for use with sops"

  read -rp "Decrypt existing encrypted files? [yes/no] " should_decrypt
  if [[ "$should_decrypt" == [Yy]* ]]; then
    decrypt_repo
  fi
}

# Decrypt the file content during checkout (smudge filter)
smudge() {
  local file="$1"
  local file_type

  if [[ -z "$file" ]]; then
    echo "Error: No file specified for smudge" >&2
    exit 2
  fi

  tmpfile=$(write_stdin_to_tmpfile)
  file_type=$(get_file_type "$file")
  if secrets decrypt "$tmpfile" "$file" "$file_type"; then
    echo "Decrypted as $file_type: $file" >&2
  else
    echo "Failed to decrypt as $file_type, may include conflicts: $file" >&2
    cat $tmpfile
  fi
}

# Encrypt the file content before staging (clean filter)
clean() {
  local file="$1"
  local file_type

  if [[ -z "$file" ]]; then
    echo "Error: No file specified for clean" >&2
    exit 2
  fi

  # If the file has not changed, reuse the existing encrypted content from HEAD
  if ! is_changed "$file"; then
    echo "Re-using unchanged file: $file" >&2
    git cat-file -p "HEAD:$file"
    return
  fi

  tmpfile=$(write_stdin_to_tmpfile)
  if is_encrypted "$tmpfile"; then
    echo "Already encrypted: $file" >&2
    cat $tmpfile
    return
  fi

  file_type=$(get_file_type "$file")
  secrets encrypt "$tmpfile" "$file" "$file_type"

  echo "Encrypted as $file_type: $file" >&2
}

if command -v mise &>/dev/null; then
  eval $(mise -C $repo_root env -s bash)
fi

# if ! command -v sops &>/dev/null; then
#   echo "Missing: sops"
#   exit 5
# fi

if [[ ! -f "$sops_config" ]]; then
  echo "Missing config: $sops_config"
  exit 4
fi

if ! git rev-parse --is-inside-work-tree &>/dev/null; then
  echo "Error: Not in a Git repo" >&2
  exit 3
fi

case $1 in
init) shift && init ;;
decrypt-repo) shift && decrypt_repo ;;
decrypt-file) shift && decrypt_repo "$1" ;;
smudge) shift && smudge "$1" ;;
clean) shift && clean "$1" ;;
*) usage ;;
esac
